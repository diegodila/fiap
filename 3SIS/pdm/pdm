logs
/opt/oracle/cfgtoollogs/dbca/XE/XE.log
---------------------------------------------------
select last_name, department_name
from employees E join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E RIGHT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = "Executive"
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    L.street_address
from employees E join departments D
on (D.department_id=E.department_id)
join locations l
on (l.location_id=d.location_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name,
    r.region_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id)
join regions r
on (r.region_id=c.region_id);

o comando externo de junção (JOIN), 
em relações opcionais de direções 
junção externa integral
relações opcionais em ambas direções OUTER
relações que devem não são opcionais são o INNER
externo é efetivo para relações opcionais

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções

em colunas ambiguas temos que qualificar a coluna
nomedatabela.nomedacoluna 
no entanto a oracle recomenda que voce qualifique com apelido, nome curto 

e.department_id 
inner join

select last_name manager, last_name worker 
from employees a join employees b
on (a.manager_id=b.manager_id)

--------------------------------------------------------
A03-300321 SUBquery

subquery pode ser usado em clausula from 
query interna e subquery  é a mesma coisa
query principal e externa é a mesma coisa
converte em join é boa pratica
tunning sql
operadores condicionais em sql não tratam listas
o tipo de dado dentro da subquery é importante no select
a subquery tem que estar entre parenteses

SELECT last_name, job_id, salary
FROM   employees
WHERE  salary = 
                (SELECT MIN(salary)
                 FROM   employees);

o operador espera um dado ele não trata lista
--função MIN() ou MAX() retorna apenas um resultado, onde o operador = aceita apenas um retorno

consistencia de grupo voce faz com having
--Where é para coluna, HAVING é para função de grupo

SELECT employee_id, last_name
FROM   employees
WHERE  salary =
                (SELECT   MIN(salary)
                 FROM     employees
                 GROUP BY department_id);

temos que usar operadores de lista

select last_name
from employees
where department_id = 20
or department_id = 50
or department_id = 70 

o in faz tudo isso internamente

select last_name 
from employees
where department_id in (20,30,80,90);

usando o in 
se voce tem um nulo na lista sua query principal é anulada

select last_name 
from employees
where department_id=&v_dept_id; --sqldeveloper

select last_name 
from employees
where department_id=?; --datagrip

--------------------------------------------------------
A04-230321

union all (uniao total mais intersecção)
não existe minus no sql server (except)

select employee_id,last_name,job_id
from employees
where department_id = (select department_id
from departments
where department_name = 'Executive');

select employee_id,last_name,job_id
from employees e join departments d
on (d.department_id=e.department_id)
where d.department_name = 'Executive';

select employee_id,last_name,job_id
from employees
where department_id=90;

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções


union all, conceito que só existe de bd relacional
table  
a quantidade colunas da primeira consulta, tem que ser igual a segunda
tem que ter o mesmo tipo de dado as colunas
voce tem colocar o nome ou apelido na primeira query
union all é a union + intersect
renomear o cabeçalho do coluna tem que ser na primeira query
quando fazemos um seleção de uma coluna inexistente, temos que fazer uma solução de contorno ex: criamos uma pseudo coluna to_number(null)--pseudo from employes, coluna_existente from job_history

quando convertamos uma coluna existente para o display do sem salario, que é um char (solução de contorno)

SELECT employee_id, job_id,to_char(salary)
FROM   employees
UNION
SELECT employee_id, job_id, 'Sem salário'
FROM   job_history;

COLUMN a_dummy NOPRINT
SELECT 'sing' AS "My dream", 3 a_dummy
FROM dual
UNION
SELECT 'I''d like to teach', 1 a_dummy
FROM dual
UNION 
SELECT 'the world to', 2 a_dummy
FROM dual
ORDER BY a_dummy;

solução de contorno 
----------------------------------------------------
A05-300321

visao é materialização logica
visao simples ou complexa
visao simples so tem uma tabela
não contem funções 
tabela temporaria é por sessao ou transação
nao podemos fazer dml 
tabela temporaria é que tem o dado temporario

subquery é qualquer instrucao de selecao valida 
o que tiver de query cabe numa visao

describe empvu80;
select * from empvu80;
update empvu80
set salary=15000
where employee_id=145;

select salary
from employees
where employee_id=145;

delete from empvu80
where employee_id=145;

delete from employees
where employee_id=145;

insert into empvu80
values (1000,'Zezao do caminhao',5000);

create or replace view


----------------------------------------------------

