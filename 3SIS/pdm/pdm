logs
/opt/oracle/cfgtoollogs/dbca/XE/XE.log
---------------------------------------------------
select last_name, department_name
from employees E join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E RIGHT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = "Executive"
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    L.street_address
from employees E join departments D
on (D.department_id=E.department_id)
join locations l
on (l.location_id=d.location_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name,
    r.region_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id)
join regions r
on (r.region_id=c.region_id);

o comando externo de junção (JOIN), 
em relações opcionais de direções 
junção externa integral
relações opcionais em ambas direções OUTER
relações que devem não são opcionais são o INNER
externo é efetivo para relações opcionais

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções

em colunas ambiguas temos que qualificar a coluna
nomedatabela.nomedacoluna 
no entanto a oracle recomenda que voce qualifique com apelido, nome curto 

e.department_id 
inner join

select last_name manager, last_name worker 
from employees a join employees b
on (a.manager_id=b.manager_id)

--------------------------------------------------------
A03-300321 SUBquery

subquery pode ser usado em clausula from 
query interna e subquery  é a mesma coisa
query principal e externa é a mesma coisa
converte em join é boa pratica
tunning sql
operadores condicionais em sql não tratam listas
o tipo de dado dentro da subquery é importante no select
a subquery tem que estar entre parenteses

SELECT last_name, job_id, salary
FROM   employees
WHERE  salary = 
                (SELECT MIN(salary)
                 FROM   employees);

o operador espera um dado ele não trata lista
--função MIN() ou MAX() retorna apenas um resultado, onde o operador = aceita apenas um retorno

consistencia de grupo voce faz com having
--Where é para coluna, HAVING é para função de grupo

SELECT employee_id, last_name
FROM   employees
WHERE  salary =
                (SELECT   MIN(salary)
                 FROM     employees
                 GROUP BY department_id);

temos que usar operadores de lista

select last_name
from employees
where department_id = 20
or department_id = 50
or department_id = 70 

o in faz tudo isso internamente

select last_name 
from employees
where department_id in (20,30,80,90);

usando o in 
se voce tem um nulo na lista sua query principal é anulada

select last_name 
from employees
where department_id=&v_dept_id; --sqldeveloper

select last_name 
from employees
where department_id=?; --datagrip

--------------------------------------------------------
A04-230321

union all (uniao total mais intersecção)
não existe minus no sql server (except)

select employee_id,last_name,job_id
from employees
where department_id = (select department_id
from departments
where department_name = 'Executive');

select employee_id,last_name,job_id
from employees e join departments d
on (d.department_id=e.department_id)
where d.department_name = 'Executive';

select employee_id,last_name,job_id
from employees
where department_id=90;

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções 

-----------------------------------------------


