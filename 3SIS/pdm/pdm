logs
/opt/oracle/cfgtoollogs/dbca/XE/XE.log

diagram venn
https://blog.jooq.or    g/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/

estudar algebra relacional

---------------------------------------------------
select last_name, department_name
from employees E join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID);

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E INNER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT OUTER join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E RIGHT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'Executive' 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E LEFT join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = "Executive"
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    D.DEPARTMENT_ID PK,
    E.DEPARTMENT_ID FK
from employees E full join departments D
on (E.DEPARTMENT_ID=D.DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = null 
or e.last_name = 'Grant'
or d.department_name = 'NOC';

select E.last_name, D.department_name,
    L.street_address
from employees E join departments D
on (D.department_id=E.department_id)
join locations l
on (l.location_id=d.location_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id);

select E.last_name, D.department_name,
    L.street_address,
    c.country_name,
    r.region_name
from employees E join departments D
on (d.department_id=e.department_id)
join locations l
on (l.location_id=d.location_id)
join countries c
on (c.country_id=l.country_id)
join regions r
on (r.region_id=c.region_id);

o comando externo de junção (JOIN), 
em relações opcionais de direções 
junção externa integral
relações opcionais em ambas direções OUTER
relações que devem não são opcionais são o INNER
externo é efetivo para relações opcionais

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções

em colunas ambiguas temos que qualificar a coluna
nomedatabela.nomedacoluna 
no entanto a oracle recomenda que voce qualifique com apelido, nome curto 

e.department_id 
inner join

select last_name manager, last_name worker 
from employees a join employees b
on (a.manager_id=b.manager_id)

--------------------------------------------------------
A03-300321 SUBquery

subquery pode ser usado em clausula from 
query interna e subquery  é a mesma coisa
query principal e externa é a mesma coisa
converte em join é boa pratica
tunning sql
operadores condicionais em sql não tratam listas
o tipo de dado dentro da subquery é importante no select
a subquery tem que estar entre parenteses

SELECT last_name, job_id, salary
FROM   employees
WHERE  salary = 
                (SELECT MIN(salary)
                 FROM   employees);

o operador espera um dado ele não trata lista
--função MIN() ou MAX() retorna apenas um resultado, onde o operador = aceita apenas um retorno

consistencia de grupo voce faz com having
--Where é para coluna, HAVING é para função de grupo

SELECT employee_id, last_name
FROM   employees
WHERE  salary =
                (SELECT   MIN(salary)
                 FROM     employees
                 GROUP BY department_id);

temos que usar operadores de lista

select last_name
from employees
where department_id = 20
or department_id = 50
or department_id = 70 

o in faz tudo isso internamente

select last_name 
from employees
where department_id in (20,30,80,90);

usando o in 
se voce tem um nulo na lista sua query principal é anulada

select last_name 
from employees
where department_id=&v_dept_id; --sqldeveloper

select last_name 
from employees
where department_id=?; --datagrip

--------------------------------------------------------
A04-230321

union all (uniao total mais intersecção)
não existe minus no sql server (except)

select employee_id,last_name,job_id
from employees
where department_id = (select department_id
from departments
where department_name = 'Executive');

select employee_id,last_name,job_id
from employees e join departments d
on (d.department_id=e.department_id)
where d.department_name = 'Executive';

select employee_id,last_name,job_id
from employees
where department_id=90;

quando temos um relacionamento e uma das entidades não precisa de outra pra existir, ele é a entidade pai 
a chave estrangeira sendo opcional
junção externa é o não relacionado
junção externa integral
o comando externo de juncao é efetivo para relações opcionais em ambas direções


union all, conceito que só existe de bd relacional
table  
a quantidade colunas da primeira consulta, tem que ser igual a segunda
tem que ter o mesmo tipo de dado as colunas
voce tem colocar o nome ou apelido na primeira query
union all é a union + intersect
renomear o cabeçalho do coluna tem que ser na primeira query
quando fazemos um seleção de uma coluna inexistente, temos que fazer uma solução de contorno ex: criamos uma pseudo coluna to_number(null)--pseudo from employes, coluna_existente from job_history

quando convertamos uma coluna existente para o display do sem salario, que é um char (solução de contorno)

SELECT employee_id, job_id,to_char(salary)
FROM   employees
UNION
SELECT employee_id, job_id, 'Sem salário'
FROM   job_history;

COLUMN a_dummy NOPRINT
SELECT 'sing' AS "My dream", 3 a_dummy
FROM dual
UNION
SELECT 'I''d like to teach', 1 a_dummy
FROM dual
UNION 
SELECT 'the world to', 2 a_dummy
FROM dual
ORDER BY a_dummy;

solução de contorno 
----------------------------------------------------
A05-300321

visao é representação logica da tabela

visao é materialização logica
visao simples ou complexa
visao simples so tem uma tabela
não contem funções 
tabela temporaria é por sessao ou transação
nao podemos fazer dml 
tabela temporaria é que tem o dado temporario

subquery é qualquer instrucao de selecao valida 
o que tiver de query cabe numa visao

describe empvu80;
select * from empvu80;
update empvu80
set salary=15000
where employee_id=145;

select salary
from employees
where employee_id=145;

delete from empvu80
where employee_id=145;

delete from employees
where employee_id=145;

insert into empvu80
values (1000,'Zezao do caminhao',5000);

create or replace view

sintaxe de view

o dml é feito usando a visao porem ele é feito na tabela
a visao reflete as consultas que foram criadas nela, alterando a tabela 

delete from empvu80
where employee_id=145;

temos um constraint da tabela, que apresenta um erro quando queremos deletar o funcionario employee_id 145 
ele é chefe de um departamento
a visao se refere a uma tabela
a visao tem que manipular todas as colunas obrigatorias para fazer insert
desde que voce tenha todas as colunas obrigatorias
se usamos expressão é obrigatorio apelidar a coluna
a coluna expressão tem que conter um apelido

não conseguimos fazer update em expressao

update salvu50
set ann_salary=50000;

virtual column not allowed here
podemos colocar os apelidos das colunas no cabeçalho da visao

CREATE OR REPLACE VIEW empvu80
  (id_number, name, sal, department_id)
AS SELECT  employee_id, first_name || ' ' 
           || last_name, salary, department_id
   FROM    employees
   WHERE   department_id = 80;


or replace mantem os privilegios da visao 
dropando nao mantem os privilegios
podemos dar um grant de select para todos manipular a visao 

select * from pf0645.empvu80;

grant é comando data control language

grant select on empvu80 to rm80263; --estou dando permissões

drop view empvu80; --perdemos todos os privilegios

quando dropamos, é create novo 
na maioria da oracle database o replace é para manter privilegios

podemos entrar com umas constraint de visao 
restringi apenas a leitura;

CREATE OR REPLACE VIEW empvu10
    (employee_number, employee_name, job_title)
AS SELECT	employee_id, last_name, job_id
   FROM     employees
   WHERE    department_id = 10
   WITH READ ONLY ;

aqui podemos manipular um funcionario onde a visão não enxerga, como o department_id fora do 20

CREATE OR REPLACE VIEW empvu20
AS SELECT	*
   FROM     employees
   WHERE    department_id = 20;

select * from empvu20;

rollback;

update empvu20
set department_id=10
where employee_id=201;

criamos uma constraint que só manipula o departamento
onde o where condition manda, so podemos deixar o funcionario dentro do dominio 
nao podemos permitir que a visao manipule dados que ela não exibe, CHECK OPTION é uma restrição, garante que a visao não manipule dados que ela não exibe

CREATE OR REPLACE VIEW empvu20
AS SELECT	*
   FROM     employees
   WHERE    department_id = 20
   WITH CHECK OPTION CONSTRAINT empvu20_ck;

----------------------------------------------------
A06-060421 Indices - Sequencia

select table_name, index_name
from user_indexes
where table_name = 'SIS3_1'

truncate table SIS3_1; -- esvaziar a tabela

select employee_id, last_name
from employees
where employee_id=170;

procuramos indexar as colunas na clausula where

select employee_id, last_name
from employees
where last_name='Pataballa';

create index emp_ln_idx
on employees(last_name);

----------------------------------------------------
A07
----------------------------------------------------
A08
correction
----------------------------------------------------
A09
plsql é tipo um linguagem de programação no sql
(tipos de laços plsql) (comandos condicionais dml - dtl)

ddl(não tem plsql) pressupoe que voce ja tenha as tabelas(create,drop,)

plsql permite que crie cursores, constantes, variaveis
cursores é onde armazenamos dados em memoria

quando retorna uma linha eu armazeno em variaveis
se as estruturas de seleção retornarem mais de uma linha armazenamos em cursores

o Plsql é um produto da oracle, que escreveu e tem direitos é a oracle
necessidade de programar no sql server são conceitos extremamentes diferentes, comandos diferentes, sintaxe diferentes. Microsoft escreve a linguaguem de acordo com os paradigmas dela

a estrutura do banco do banco de dados, arquitetura do banco de dados, essa estruturas são diferentes de cada fabricante, se precisar migrar do plsql para o transaction sql talvez voce precise reescrever tode o codigo. Não adianta fazer o depara

O melhor sgbd é o que resolve os problemas de negocio, ou da empresa

Um dos bancos de dados da ibm, Db2- quando migramos dados, pode ser feito de varias maneiras. A ibm resolveu fazer a compatibilização de 100 para atender o plsql. Porque migrar dados é facil, dificil é migrar codigo.

programar no back end ou bd. Atualmente temos do dois jeitos
sempre vamos encontrar alguma coisa do dois lados
vantagens é que podemos jogar o processamento para o sgbd
o ambiente plsql tem um problema (quando disparamos um bloco de prog, tem 12 engines que vão entrar na interpretação desse bloco e prog, tem bloco que process query language)

quando começamos o laço(10 interações, com instruções de insert) a engine que tem controle, é a engine de plsql, depois se temos um insert a engine troca de contexto, entrando a engine sql realizando o insert, depois quando o laço vai fazer o teste condicional de saída volta o contexto para o sql engine

troca de contexto (engine pl/sql) uma engine que processa prog e sql (troca de contexto)

bloco anonimo (declare, begin, exception, end). definimos se a estrutura sera um procedimento ou uma função
o bloco é formado por 3 div e só uma obrigatoria, a sessao Begin End
comando  declaração plsql entender como (laços e condicionais)
cursores são estruturas de memoria que armazenam comandos sql
dentro de cursores, similires a uma lista, array

podemos tratar exceptions, definida, não pré definida, e a que eu crio

tipos de blocos anonima, procedure, function
quando escrevemos um procedimento não retorna nada para o ambiente de chamada, ja uma função sim
o procedimento ele pode, não é obrigatorio

a diferença que bloco anonimo não tem nome, e procedimento tem
o declare da procedure é o IS
se precisamos sempre retornar um dado é tem a function o com return

os triggers é um obj de progra, quando invocamos, os gatilhos são programados quando algo acontecer
tipo de bloco triggers
quando acontecer o evento, gatilho(trigger)

outra estrutura pkgs(contem procedures ou functions) variaveis publicas e privadas

/ A BARRA É UM EXEC IMEDIATO
-- comentario de linha
O PACOTE QUE O PUT_LINE ESTÁ DENTRO CHAMA SE DBMS_OUTPUT
PACOTE.PROCEDURE
o put_line tem que ser ligado, habilitando a saida

comando de ambiente não podemos colocar dentro do bloco

O PIPE É USADO PARA JUNTAR PARA CONCATENAR

CHR(10) É USADO PARA QUEBRAR LINHA  OU CHR(13)

utilização de variáveis podem ser usadas para:

identificadores como declararar variveis  
é importante padronizar v_ c_ reg_
padronização de nomeclatura
evitando retrabalho 

a varivel é atribuida com := 
podemos atribuir tambem com default 
v_emp_id number(5) default 3;

%TYPE voce esta pedindo pra ele ir na tabela e pegar o tipo dele
%TYPE  ELE VAI NA TABLE E JA ATRIBUI A TYPE A 
----------------------------------------------------
A10
----------------------------------------------------
A11
----------------------------------------------------
